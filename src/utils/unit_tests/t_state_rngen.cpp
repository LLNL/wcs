#if defined(WCS_HAS_CONFIG)
#include "wcs_config.hpp"
#else
#error "no config"
#endif

#include <iostream>
#include <sstream>
#include <cstdint>
#include "utils/rngen.hpp"
#include "utils/state_io.hpp"

#if defined(WCS_HAS_CATCH2)
#include <cstddef>
#define CATCH_CONFIG_MAIN
#include "catch2/catch.hpp"
#endif // defined(WCS_HAS_CATCH2)

enum MethodT {Cereal, Bits};
enum StreamBufT {StreamVec, StreamBuff, StringStream};

template <typename RNGenT,
          typename CharT = char,
          typename Traits = std::char_traits<CharT> >
std::basic_ostream<CharT, Traits>&
save_state_os(const RNGenT& rgen,
              const MethodT method,
              std::basic_ostream<CharT, Traits>& os)
{
  if (method == Cereal) {
  #if defined(WCS_HAS_CEREAL)
    cereal::BinaryOutputArchive oarchive(os);
    oarchive(rgen); // Write the data to the archive
  #endif // defined(WCS_HAS_CEREAL)
  } else {
    rgen.save_bits(os);
  }
  return os;
}

template <typename RNGenT,
          typename CharT = char,
          typename Traits = std::char_traits<CharT> >
std::basic_istream<CharT, Traits>&
load_state_is(RNGenT& rgen,
              const MethodT method,
              std::basic_istream<CharT, Traits>& is)
{
  if (method == Cereal) {
  #if defined(WCS_HAS_CEREAL)
    cereal::BinaryInputArchive iarchive(is);
    iarchive(rgen); // Write the data to the archive
  #endif // defined(WCS_HAS_CEREAL)
  } else {
    rgen.load_bits(is);
  }
  return is;
}

template <typename RNGenT>
bool save_to_streamvec(const MethodT method,
                       const RNGenT& rgen,
                       std::vector<char>& buf,
                       const size_t space_to_reserve = 0ul)
{
  buf.reserve(space_to_reserve);

  // dump the serialized rgen state into buf
  wcs::ostreamvec<char> ostrmbuf(buf);
  std::ostream os(&ostrmbuf);
  save_state_os(rgen, method, os);
  return os.good();
}

template <typename RNGenT>
bool save_to_streambuff(const MethodT method,
                        const RNGenT& rgen,
                        char* buf,
                        size_t capacity_preallocated)
{
  // dump the serialized rgen state into buf
  wcs::ostreambuff<char> ostrmbuf(buf, capacity_preallocated);
  std::ostream os(&ostrmbuf);
  save_state_os(rgen, method, os);
  return os.good();
}

template <typename RNGenT>
bool load_from_streamvec(const MethodT method,
                         RNGenT& rgen,
                         const std::vector<char>& buf)
{
  // dump the serialized rgen state into buf
  wcs::istreamvec<char> istrmbuf(buf);
  std::istream is(&istrmbuf);
  load_state_is(rgen, method, is);
  return is.good();
}

template <typename RNGenT>
bool load_from_streambuff(const MethodT method,
                          RNGenT& rgen,
                          char* buf,
                          size_t capacity_preallocated)
{
  // dump the serialized rgen state into buf
  wcs::istreambuff<char> istrmbuf(buf, capacity_preallocated);
  std::istream is(&istrmbuf);
  load_state_is(rgen, method, is);
  return is.good();
}

/**
 * \test Test save/load the state of #wcs::RNGen using Cereal or Bits
 * serialization method toghether with #wcs::streamvec or wcs::streambuf
 * buffering. The test is to generate some number of random numbers using one
 * RNGen object first. Then, save the staete of the object, and load it into
 * another RNGen object. Finally, compare the two sequences of random numbers
 * further generated by the two RNGen objects. When they are identical, retun
 * true. Otherwise, return false.
 *
 * \tparam<RNGenT>{, the first template parameter, is the type of wcs::RNGen object.
 * This class consists of members of various types including boolean, integer,
 * vector, and rng engine, std::distribution structure.}
 *
 * @param[in] p is the distribution parameter to initialize RNGen object.
 * @param[in] method indicates which serialization method to use.
 * @param[in] buftype indicates which buffering mechanism to use.
 * @param[out] sstr outputs the random number sequences compared.
 * @param[in] reserve_space indicates whether to reserve space in advance when
 * using #wcs::streamvec. The default is true.
 */
template<typename RNGenT, typename RNGenParamT = typename RNGenT::param_type>
inline bool test_RNGen_state_io(const RNGenParamT& p,
                                const MethodT method,
                                const StreamBufT buftype,
                                std::stringstream& sstr,
                                const bool reserve_space = true)
{
  #if !defined(WCS_HAS_CEREAL)
  if (method == Cereal) {
    std::cerr << "Cereal is not enabled!" << std::endl;
    return false;
  }
  #endif // defined(WCS_HAS_CEREAL)

  static_assert(std::is_same<typename RNGenT::param_type, RNGenParamT>::value,
                "Invalid paramter type");

  // number of random numbers to show before making copy
  size_t n_before = 4;
  size_t n_after = 4;

  RNGenT rgen;
  RNGenT rgen2;
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  rgen.use_seed_seq({seed, 47u});
  //rgen.set_seed(seed);
  rgen.param(p);

  std::string rnseq1;
  std::string rnseq2;

  sstr << "Duplicate after " << n_before << " pulls" << std::endl;
  sstr << "RNG original  :";
  size_t head_len = sstr.str().size();

  for (size_t i = 0ul; i < n_before; i++) {
    sstr << ' ' << rgen();
  }

  bool ok_o = false;
  bool ok_i = false;
  std::vector<char> buf;
  std::stringstream sstrm;

  if (buftype == StreamVec) {
    if (reserve_space) {
      buf.reserve(rgen.byte_size());
      // buf.resize(rgen.byte_size()) also works for ostream.
      // However, only reserve() works for iostream because if
      // the buffer is not empty, iostream will read data from it.
    }
    ok_o = save_to_streamvec(method, rgen, buf);
  } else if (buftype == StreamBuff) {
    // Pretend that buf is a C-stype array
    size_t capacity = rgen.byte_size()*2; // enough to cover alignment padding
    buf.resize(capacity);
    ok_o = save_to_streambuff(method, rgen, buf.data(), capacity);
  } else if (buftype == StringStream) {
    save_state_os(rgen, method, sstrm);
    ok_o = sstrm.good();
  }
  if (!ok_o) return false;

  for (size_t i = 0ul; i < n_after; i++) {
    rnseq1 += ' ' + std::to_string(rgen());
  }
  size_t space_len = sstr.str().size();
  sstr << rnseq1 << std::endl;

  sstr << "RNG duplicate :";
  if (buftype == StreamVec) {
    ok_i = load_from_streamvec(method, rgen2, buf);
  } else if (buftype == StreamBuff) {
    // Pretend that buf is a C-stype array
    ok_i = load_from_streambuff(method, rgen2, buf.data(), buf.size());
  } else if (buftype == StringStream) {
    load_state_is(rgen2, method, sstrm);
    ok_i = sstrm.good();
  }
  if (!ok_i) return false;

  sstr << std::string(space_len-head_len, ' ');

  for (size_t i = 0ul; i < n_after; i++) {
    rnseq2 += ' ' + std::to_string(rgen2());
  }
  sstr << rnseq2 << std::endl;

  return (rnseq1 == rnseq2);
}

#if defined(WCS_HAS_CATCH2)
#define CHECK_RESULT REQUIRE(ok == true)
TEST_CASE( "RNGen State IO", "[state I/O]" )
#else
#define CHECK_RESULT \
          std::cout << sstr.str(); \
          std::cout << (ok? "PASS" : "FAILED") << std::endl << std::endl;
#define SECTION(T) std::cout << T << std::endl;

int main (int argc, char** argv)
#endif
{
  using rng_uint_t = wcs::RNGen<std::uniform_int_distribution, unsigned>;
  using rng_double_t = wcs::RNGen<std::uniform_real_distribution, double>;

  bool ok = false;
  
  // StreamVec
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using Cereal and StreamVec")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Cereal, StreamVec, sstr);
    CHECK_RESULT;
  }

  SECTION("Save and load the state of RNGen based on real type uniform "
          "distribution using Cereal and StreamVec")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
           Cereal, StreamVec, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using the WCS native method Bits and StreamVec")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Bits, StreamVec, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on real type uniform "
          "distribution using the WCS native method Bits and StreamVec")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
           Bits, StreamVec, sstr);
    CHECK_RESULT;
  }

  // StreamBuff
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using Cereal and StreamBuff")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Cereal, StreamBuff, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on real type uniform "
          "distribution using Cereal and StreamBuff")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
           Cereal, StreamBuff, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using the WCS native method Bits and StreamBuff")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Bits, StreamBuff, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on real type uniform "
          "distribution using the WCS native method Bits and StreamBuff")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
           Bits, StreamBuff, sstr);
    CHECK_RESULT;
  }

  // std::stringstream
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using Cereal and std::stringstream")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Cereal, StringStream, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on real type uniform "
          "distribution using Cereal and std::stringstream")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
           Cereal, StringStream, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using the WCS native method Bits and std::stringstream")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Bits, StringStream, sstr);
    CHECK_RESULT;
  }
  SECTION("Save and load the state of RNGen based on real type uniform "
          "distribution using the WCS native method Bits and std::stringstream")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
           Bits, StringStream, sstr);
    CHECK_RESULT;
  }

  // StreamVec with no space reservation
  SECTION("Save and load the state of RNGen based on integer type uniform "
          "distribution using Cereal and StreamVec withtout space reservation")
  {
    std::stringstream sstr;
    ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
           Cereal, StreamVec, sstr, false);
    CHECK_RESULT;
  }
#if !defined(WCS_HAS_CATCH2)
  return 0;
#endif
}
